# Overview

The Backglass 2 coprocessor firmware consists of two main functions: a "main" loop that handles I2C (Two-Wire Interface) communications, and a regular timer interrupt that handles audio and display output. The main loop calculates updated values for use by the timer interrupt, and writes these to a series of buffer arrays. Once the I2C packet is fully received, the active and buffer arrays are swapped as needed.

These arrays include *VoiceArray* (containing the duty cycle of each channel), *VolumeArray* (self explanatory), and *DurationArray* (containing both the low and high period of the current waveform for each channel, using 16-bit values). When swapping active and buffer arrays, VoiceArray and VolumeArray are grouped together as the "*meta*" arrays.

# Timer Interrupt

The timer interrupt is generated by the Timer1 unit, which is configured in fast PWM mode with a TOP value of 252 (63 * 4, the maximum allowable amplitude). No prescaler is used, and the interrupt therefore runs at approximately 63 kHz. When an interrupt is generated, the Timer1 Overflow Interrupt Service Routine (TOV1_ISR) is run, halting the I2C code temporarily.

>### How Fast PWM Mode Operates
>The Timer1 unit consists of a counter that starts at zero, and counts to TOP, incrementing by 1 every clock cycle. When TOP is reached, an interrupt is generated, and the counter is reset to zero at the next clock cycle. During this counting, the current value is constantly compared to the Output Compare Register (*OCR1A*), which is calculated and updated by the interrupt routine. If the current value is less than OCR1A, the speaker output is set high. If it is lower, it is set low. As this process is repeated far above audible frequencies, the speaker acts as a lowpass filter for these pulses of varying widths, and it is thus considered that the OCR1A controls the value of the analogue output for the speaker.

### Audio Output
The interrupt routine first calculates the remaining period for each channel's waveform, and updates both the channel's phase and remaining period if the current phase of the waveform is complete. Below is a C interpretation of the code, showing only channel 0. Fully-lowercase variables are temporary.
```C
// Load channel data
uint8_t  channel_0_phase = ChannelPhaseArray[0];
uint8_t  channel_0_volume = VolumeArray[META_BANK_SELECT & 0x04][0];
uint16_t channel_0_remaining = RemainingArray[0];

// Update channel data
channel_0_remaining -= 1;
if (channel_0_remaining == 0):
	channel_0_phase = ~(channel_0_phase);
	channel_0_remaining = DurationArray[DURATION_BANK_SELECT & 0x10][0][channel_0_phase & 0x01];
	if (channel_0_remaining == 1):
		channel_0_volume = 0;

// Save channel data
RemainingArray[0] = channel_0_remaining;
ChannelPhaseArray[0] = channel_0_phase;
```
Note that the bank select and channel phase variables are always either 0x00 or 0xFF. This allows them to be easily complemented and/or masked for various operations.

Also note that if a new period of 1 is detected, the channel is temporarily muted. This is used to handle REST notes.

Once all channels are updated, the speaker output is calculated for the next cycle:

```C
OCR1A = ((channel_0_phase * channel_0_volume) + other channels);
```

### Display Output
Once the speaker output is updated, the display output is updated. One digit is displayed at a time, and the currently displayed digit is shifted once every interrupt cycle. The current selection is stored in a dedicated register, *CURRENT_DIGIT*, which always contains the value *0x11*, *0x22*, *0x44*, or *0x88*. By circular shifting left, the next digit can be selected. The byte values for each digit are stored in locations *0x0211*, *0x0222*, *0x0244*, and *0x0288*. This allows for the value of the current digit to be easily fetched from memory using CURRENT_DIGIT.

PORTD is used entirely to output the 8 segments of the current digit. The digit select outputs are PORTC bits 0, 1, 2, and 3.

Below is a C interpretation of the display update code. Fully-lowercase variables are temporary.
```C
CURRENT_DIGIT = ((CURRENT_DIGIT << 1) + ((CURRENT_DIGIT & 0xF) >> 7)); // Circular shift left

uint8_t current_digit_output = *(0x0200 + CURRENT_DIGIT);              // Load new digit's segment data

PORTD = 0;                                                             // Blank display while switching digit
PORTC = ((PORTC & 0xF0) | (CURRENT_DIGIT & 0x0F));                     // Select new digit
PORTD = current_digit_output;                                          // Display new digit
```

# Two-Wire Interface

**TODO**
